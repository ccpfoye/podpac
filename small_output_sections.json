[
    {
        "file": "/home/cfoye/podpac/podpac/core/compositor/test/test_ordered_compositor.py",
        "comments": [],
        "docstrings": [],
        "code_snippets": [
            "class TestOrderedCompositor(object):",
            "def test_composite(self):\n        with podpac.settings:\n            podpac.settings[\"MULTITHREADING\"] = False\n\n            acoords = podpac.Coordinates([[-1, 0, 1], [10, 20, 30]], dims=[\"lat\", \"lon\"])\n            asource = np.ones(acoords.shape)\n            asource[0, :] = np.nan\n            a = Array(source=asource, coordinates=acoords, interpolation=\"bilinear\")\n\n            bcoords = podpac.Coordinates([[0, 1, 2, 3], [10, 20, 30, 40]], dims=[\"lat\", \"lon\"])\n            bsource = np.zeros(bcoords.shape)\n            bsource[:, 0] = np.nan\n            b = Array(source=bsource, coordinates=bcoords, interpolation=\"bilinear\")\n\n            coords = podpac.Coordinates([[0, 1, 2], [10, 20, 30, 40, 50]], dims=[\"lat\", \"lon\"])\n\n            node = OrderedCompositor(sources=[a, b])\n            expected = np.array(\n                [[1.0, 1.0, 1.0, 0.0, np.nan], [1.0, 1.0, 1.0, 0.0, np.nan], [np.nan, np.nan, 0.0, 0.0, np.nan]]\n            )\n            np.testing.assert_allclose(node.eval(coords), expected, equal_nan=True)\n\n            node = OrderedCompositor(sources=[b, a])\n            expected = np.array(\n                [[1.0, 1.0, 0.0, 0.0, np.nan], [1.0, 1.0, 0.0, 0.0, np.nan], [np.nan, np.nan, 0.0, 0.0, np.nan]]\n            )\n            np.testing.assert_allclose(node.eval(coords), expected, equal_nan=True)",
            "def test_composite_multithreaded(self):\n        with podpac.settings:\n            podpac.settings[\"MULTITHREADING\"] = True\n            podpac.settings[\"N_THREADS\"] = 8\n\n            acoords = podpac.Coordinates([[-1, 0, 1], [10, 20, 30]], dims=[\"lat\", \"lon\"])\n            asource = np.ones(acoords.shape)\n            asource[0, :] = np.nan\n            a = Array(source=asource, coordinates=acoords, interpolation=\"bilinear\")\n\n            bcoords = podpac.Coordinates([[0, 1, 2, 3], [10, 20, 30, 40]], dims=[\"lat\", \"lon\"])\n            bsource = np.zeros(bcoords.shape)\n            bsource[:, 0] = np.nan\n            b = Array(source=bsource, coordinates=bcoords, interpolation=\"bilinear\")\n\n            coords = podpac.Coordinates([[0, 1, 2], [10, 20, 30, 40, 50]], dims=[\"lat\", \"lon\"])\n\n            node = OrderedCompositor(sources=[a, b])\n            expected = np.array(\n                [[1.0, 1.0, 1.0, 0.0, np.nan], [1.0, 1.0, 1.0, 0.0, np.nan], [np.nan, np.nan, 0.0, 0.0, np.nan]]\n            )\n            np.testing.assert_allclose(node.eval(coords), expected, equal_nan=True)\n\n            node = OrderedCompositor(sources=[b, a])\n            expected = np.array(\n                [[1.0, 1.0, 0.0, 0.0, np.nan], [1.0, 1.0, 0.0, 0.0, np.nan], [np.nan, np.nan, 0.0, 0.0, np.nan]]\n            )\n            np.testing.assert_allclose(node.eval(coords), expected, equal_nan=True)",
            "def test_composite_short_circuit(self):\n        with podpac.settings:\n            podpac.settings[\"MULTITHREADING\"] = False\n            podpac.settings[\"DEBUG\"] = True\n\n            coords = podpac.Coordinates([[0, 1], [10, 20, 30]], dims=[\"lat\", \"lon\"])\n            a = Array(source=np.ones(coords.shape), coordinates=coords, interpolation=\"bilinear\")\n            b = Array(source=np.zeros(coords.shape), coordinates=coords, interpolation=\"bilinear\")\n            node = OrderedCompositor(sources=[a, b])\n            output = node.eval(coords)\n            np.testing.assert_array_equal(output, a.source)\n            assert node._eval_sources[0]._output is not None\n            assert node._eval_sources[1]._output is None",
            "def test_composite_short_circuit_multithreaded(self):\n        with podpac.settings:\n            podpac.settings[\"MULTITHREADING\"] = True\n            podpac.settings[\"N_THREADS\"] = 8\n            podpac.settings[\"DEBUG\"] = True\n\n            coords = podpac.Coordinates([[0, 1], [10, 20, 30]], dims=[\"lat\", \"lon\"])\n            n_threads_before = podpac.core.managers.multi_threading.thread_manager._n_threads_used\n            a = Array(source=np.ones(coords.shape), coordinates=coords, interpolation=\"bilinear\")\n            b = Array(source=np.zeros(coords.shape), coordinates=coords, interpolation=\"bilinear\")\n            node = OrderedCompositor(sources=[a, b], multithreading=True)\n            node2 = OrderedCompositor(sources=[a, b], multithreading=False)\n            output = node.eval(coords)\n            output2 = node2.eval(coords)\n            np.testing.assert_array_equal(output, a.source)\n            np.testing.assert_array_equal(output2, a.source)\n            assert node._multi_threaded == True\n            assert node2._multi_threaded == False\n            assert podpac.core.managers.multi_threading.thread_manager._n_threads_used == n_threads_before",
            "def test_composite_into_result(self):\n        coords = podpac.Coordinates([[0, 1], [10, 20, 30]], dims=[\"lat\", \"lon\"])\n        a = Array(source=np.ones(coords.shape), coordinates=coords, interpolation=\"bilinear\")\n        b = Array(source=np.zeros(coords.shape), coordinates=coords, interpolation=\"bilinear\")\n        node = OrderedCompositor(sources=[a, b])\n        result = node.create_output_array(coords, data=np.random.random(coords.shape))\n        output = node.eval(coords, output=result)\n        np.testing.assert_array_equal(output, a.source)\n        np.testing.assert_array_equal(result, a.source)",
            "def test_composite_multiple_outputs(self):\n        node = OrderedCompositor(sources=[MULTI_0_XY, MULTI_1_XY], auto_outputs=True)\n        output = node.eval(COORDS)\n        assert output.dims == (\"lat\", \"lon\", \"time\", \"output\")\n        np.testing.assert_array_equal(output[\"output\"], [\"x\", \"y\"])\n        np.testing.assert_array_equal(output.sel(output=\"x\"), np.full(COORDS.shape, 0))\n        np.testing.assert_array_equal(output.sel(output=\"y\"), np.full(COORDS.shape, 0))\n\n        node = OrderedCompositor(sources=[MULTI_1_XY, MULTI_0_XY], auto_outputs=True)\n        output = node.eval(COORDS)\n        assert output.dims == (\"lat\", \"lon\", \"time\", \"output\")\n        np.testing.assert_array_equal(output[\"output\"], [\"x\", \"y\"])\n        np.testing.assert_array_equal(output.sel(output=\"x\"), np.full(COORDS.shape, 1))\n        np.testing.assert_array_equal(output.sel(output=\"y\"), np.full(COORDS.shape, 1))",
            "def test_composite_combine_multiple_outputs(self):\n        node = OrderedCompositor(sources=[MULTI_0_XY, MULTI_1_XY, MULTI_2_X, MULTI_3_Z], auto_outputs=True)\n        output = node.eval(COORDS)\n        assert output.dims == (\"lat\", \"lon\", \"time\", \"output\")\n        np.testing.assert_array_equal(output[\"output\"], [\"x\", \"y\", \"z\"])\n        np.testing.assert_array_equal(output.sel(output=\"x\"), np.full(COORDS.shape, 0))\n        np.testing.assert_array_equal(output.sel(output=\"y\"), np.full(COORDS.shape, 0))\n        np.testing.assert_array_equal(output.sel(output=\"z\"), np.full(COORDS.shape, 3))\n\n        node = OrderedCompositor(sources=[MULTI_3_Z, MULTI_2_X, MULTI_0_XY, MULTI_1_XY], auto_outputs=True)\n        output = node.eval(COORDS)\n        assert output.dims == (\"lat\", \"lon\", \"time\", \"output\")\n        np.testing.assert_array_equal(output[\"output\"], [\"z\", \"x\", \"y\"])\n        np.testing.assert_array_equal(output.sel(output=\"x\"), np.full(COORDS.shape, 2))\n        np.testing.assert_array_equal(output.sel(output=\"y\"), np.full(COORDS.shape, 0))\n        np.testing.assert_array_equal(output.sel(output=\"z\"), np.full(COORDS.shape, 3))\n\n        node = OrderedCompositor(sources=[MULTI_2_X, MULTI_4_YX], auto_outputs=True)\n        output = node.eval(COORDS)\n        assert output.dims == (\"lat\", \"lon\", \"time\", \"output\")\n        np.testing.assert_array_equal(output[\"output\"], [\"x\", \"y\"])\n        np.testing.assert_array_equal(output.sel(output=\"x\"), np.full(COORDS.shape, 2))\n        np.testing.assert_array_equal(output.sel(output=\"y\"), np.full(COORDS.shape, 4))",
            "def test_composite_stacked_unstacked(self):\n        anative = podpac.Coordinates([podpac.clinspace((0, 1), (1, 2), size=3)], dims=[\"lat_lon\"])\n        bnative = podpac.Coordinates([podpac.clinspace(-2, 3, 3), podpac.clinspace(-1, 4, 3)], dims=[\"lat\", \"lon\"])\n        a = Array(source=np.random.rand(3), coordinates=anative, interpolation=\"nearest\")\n        b = Array(source=np.random.rand(3, 3) + 2, coordinates=bnative, interpolation=\"nearest\")\n\n        coords = podpac.Coordinates([podpac.clinspace(-3, 4, 32), podpac.clinspace(-2, 5, 32)], dims=[\"lat\", \"lon\"])\n\n        node = OrderedCompositor(sources=[a, b])\n        o = node.eval(coords)\n        # Check that both data sources are being used in the interpolation\n        assert np.any(o.data >= 2)\n        assert np.any(o.data <= 1)",
            "def test_composite_extra_dims(self):\n        with podpac.settings:\n            podpac.settings[\"MULTITHREADING\"] = False\n\n            coords = podpac.Coordinates([[0, 1], [10, 20, 30]], dims=[\"lat\", \"lon\"])\n            a = Array(source=np.ones(coords.shape), coordinates=coords, interpolation=\"bilinear\")\n\n            extra = podpac.Coordinates([coords[\"lat\"], coords[\"lon\"], \"2020-01-01\"], dims=[\"lat\", \"lon\", \"time\"])\n\n            # dims not provided, eval fails with extra dims\n            node = OrderedCompositor(sources=[a])\n            np.testing.assert_array_equal(node.eval(coords), a.source)\n            with pytest.raises(podpac.NodeException, match=\"Cannot evaluate compositor with requested dims\"):\n                node.eval(extra)\n\n            # dims provided, remove extra dims\n            node = OrderedCompositor(sources=[a], dims=[\"lat\", \"lon\"])\n            np.testing.assert_array_equal(node.eval(coords), a.source)\n            np.testing.assert_array_equal(node.eval(extra), a.source)"
        ]
    },
    {
        "file": "/home/cfoye/podpac/podpac/core/compositor/test/test_base_compositor.py",
        "comments": [],
        "docstrings": [],
        "code_snippets": [
            "class MockComposite(BaseCompositor):",
            "def composite(self, coordinates, outputs, result=None):\n        if result is None:\n            result = self.create_output_array(coordinates)\n        output = next(outputs)\n        try:\n            result[:] = output.transpose(*result.dims)\n        except ValueError:\n            raise podpac.NodeException(\"Cannot evaluate compositor with requested dims\")\n        return result",
            "class TestBaseCompositor(object):",
            "def test_init(self):\n        node = BaseCompositor(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME])\n        repr(node)",
            "def test_source_coordinates(self):\n        # none (default)\n        node = BaseCompositor(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME])\n        assert node.source_coordinates is None\n\n        # unstacked\n        node = BaseCompositor(\n            sources=[podpac.algorithm.Arange(), podpac.algorithm.SinCoords()],\n            source_coordinates=podpac.Coordinates([[0, 1]], dims=[\"time\"]),\n        )\n\n        # stacked\n        node = BaseCompositor(\n            sources=[podpac.algorithm.Arange(), podpac.algorithm.SinCoords()],\n            source_coordinates=podpac.Coordinates([[[0, 1], [10, 20]]], dims=[\"time_alt\"]),\n        )\n\n        # invalid size\n        with pytest.raises(ValueError, match=\"Invalid source_coordinates, source and source_coordinates size mismatch\"):\n            node = BaseCompositor(\n                sources=[podpac.algorithm.Arange(), podpac.algorithm.SinCoords()],\n                source_coordinates=podpac.Coordinates([[0, 1, 2]], dims=[\"time\"]),\n            )\n\n        with pytest.raises(ValueError, match=\"Invalid source_coordinates, source and source_coordinates size mismatch\"):\n            node = BaseCompositor(\n                sources=[podpac.algorithm.Arange(), podpac.algorithm.SinCoords()],\n                source_coordinates=podpac.Coordinates([[0, 1, 2]], dims=[\"time\"]),\n            )\n\n        # invalid ndims\n        with pytest.raises(ValueError, match=\"Invalid source_coordinates\"):\n            node = BaseCompositor(\n                sources=[podpac.algorithm.Arange(), podpac.algorithm.SinCoords()],\n                source_coordinates=podpac.Coordinates([[0, 1], [10, 20]], dims=[\"time\", \"alt\"]),\n            )",
            "def test_select_sources_default(self):\n        node = BaseCompositor(sources=[DataSource(), DataSource(), podpac.algorithm.Arange()])\n        sources = node.select_sources(podpac.Coordinates([[0, 10]], [\"time\"]))\n\n        assert isinstance(sources, list)\n        assert len(sources) == 3",
            "def test_select_sources_intersection(self):\n        source_coords = podpac.Coordinates([[0, 10]], [\"time\"])\n        node = BaseCompositor(sources=[DataSource(), DataSource()], source_coordinates=source_coords)\n\n        # select all\n        selected = node.select_sources(source_coords)\n        assert len(selected) == 2\n        assert selected[0] == node.sources[0]\n        assert selected[1] == node.sources[1]\n\n        # select first\n        c = podpac.Coordinates([podpac.clinspace(0, 1, 10), podpac.clinspace(0, 1, 11), 0], [\"lat\", \"lon\", \"time\"])\n        selected = node.select_sources(c)\n        assert len(selected) == 1\n        assert selected[0] == node.sources[0]\n\n        # select second\n        c = podpac.Coordinates([podpac.clinspace(0, 1, 10), podpac.clinspace(0, 1, 11), 10], [\"lat\", \"lon\", \"time\"])\n        selected = node.select_sources(c)\n        assert len(selected) == 1\n        assert selected[0] == node.sources[1]\n\n        # select none\n        c = podpac.Coordinates([podpac.clinspace(0, 1, 10), podpac.clinspace(0, 1, 11), 100], [\"lat\", \"lon\", \"time\"])\n        selected = node.select_sources(c)\n        assert len(selected) == 0",
            "def test_iteroutputs_empty(self):\n        node = BaseCompositor(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME])\n        outputs = node.iteroutputs(podpac.Coordinates([-1, -1, -1], dims=[\"lat\", \"lon\", \"time\"]))\n        np.testing.assert_array_equal(next(outputs), [[[np.nan]]])\n        np.testing.assert_array_equal(next(outputs), [[[np.nan]]])\n        np.testing.assert_array_equal(next(outputs), [[[np.nan]]])\n        with pytest.raises(StopIteration):\n            next(outputs)",
            "def test_iteroutputs_singlethreaded(self):\n        with podpac.settings:\n            podpac.settings[\"MULTITHREADING\"] = False\n\n            node = BaseCompositor(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME])\n            outputs = node.iteroutputs(COORDS)\n            np.testing.assert_array_equal(next(outputs), LAT)\n            np.testing.assert_array_equal(next(outputs), LON)\n            np.testing.assert_array_equal(next(outputs), TIME)\n            with pytest.raises(StopIteration):\n                next(outputs)\n            assert node._multi_threaded == False",
            "def test_iteroutputs_multithreaded(self):\n        with podpac.settings:\n            podpac.settings[\"MULTITHREADING\"] = True\n            podpac.settings[\"N_THREADS\"] = 8\n\n            n_threads_before = podpac.core.managers.multi_threading.thread_manager._n_threads_used\n            node = BaseCompositor(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME])\n            outputs = node.iteroutputs(COORDS)\n            np.testing.assert_array_equal(next(outputs), LAT)\n            np.testing.assert_array_equal(next(outputs), LON)\n            np.testing.assert_array_equal(next(outputs), TIME)\n            with pytest.raises(StopIteration):\n                next(outputs)\n            assert node._multi_threaded == True\n            assert podpac.core.managers.multi_threading.thread_manager._n_threads_used == n_threads_before",
            "def test_iteroutputs_n_threads_1(self):\n        with podpac.settings:\n            podpac.settings[\"MULTITHREADING\"] = True\n            podpac.settings[\"N_THREADS\"] = 1\n\n            n_threads_before = podpac.core.managers.multi_threading.thread_manager._n_threads_used\n            node = BaseCompositor(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME])\n            outputs = node.iteroutputs(COORDS)\n            np.testing.assert_array_equal(next(outputs), LAT)\n            np.testing.assert_array_equal(next(outputs), LON)\n            np.testing.assert_array_equal(next(outputs), TIME)\n            with pytest.raises(StopIteration):\n                next(outputs)\n            assert node._multi_threaded == False\n            assert podpac.core.managers.multi_threading.thread_manager._n_threads_used == n_threads_before",
            "def test_composite(self):\n        node = BaseCompositor(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME])\n        with pytest.raises(NotImplementedError):\n            node.composite(COORDS, iter(()))",
            "def test_eval(self):\n        node = BaseCompositor(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME])\n        with pytest.raises(NotImplementedError):\n            node.eval(COORDS)\n\n        node = MockComposite(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME])\n        output = node.eval(COORDS)\n        np.testing.assert_array_equal(output, LAT)",
            "def test_eval_extra_dims(self):\n        coords = COORDS.drop(\"time\")\n        a = Array(source=np.ones(coords.shape), coordinates=coords)\n        b = Array(source=np.zeros(coords.shape), coordinates=coords)\n\n        # no dims provided, evaluation fails with extra requested dims\n        node = MockComposite(sources=[a, b])\n        np.testing.assert_array_equal(node.eval(coords), a.source)\n        with pytest.raises(podpac.NodeException, match=\"Cannot evaluate compositor with requested dims\"):\n            node.eval(COORDS)\n\n        # dims provided, evaluation should succeed with extra requested dims\n        node = MockComposite(sources=[a, b], dims=[\"lat\", \"lon\"])\n        np.testing.assert_array_equal(node.eval(coords), a.source)\n        np.testing.assert_array_equal(node.eval(COORDS), a.source)\n\n        # drop stacked dimensions if none of its dimensions are needed\n        c = podpac.Coordinates(\n            [COORDS[\"lat\"], COORDS[\"lon\"], [COORDS[\"time\"], [10, 20]]], dims=[\"lat\", \"lon\", \"time_alt\"]\n        )\n        np.testing.assert_array_equal(node.eval(c), a.source)\n\n        # TODO\n        # but don't drop stacked dimensions if any of its dimensions are needed\n        # c = podpac.Coordinates([[COORDS['lat'], COORDS['lon'], np.arange(COORDS['lat'].size)]], dims=['lat_lon_alt'])\n        # np.testing.assert_array_equal(node.eval(c), np.ones(COORDS['lat'].size))\n\n        # dims can also be specified by the node",
            "class MockComposite2(MockComposite):\n            dims = [\"lat\", \"lon\"]\n\n        node = MockComposite2(sources=[a, b])\n        np.testing.assert_array_equal(node.eval(coords), a.source)\n        np.testing.assert_array_equal(node.eval(COORDS), a.source)",
            "def test_find_coordinates(self):\n        node = BaseCompositor(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME])\n\n        coord_list = node.find_coordinates()\n        assert isinstance(coord_list, list)\n        assert len(coord_list) == 3",
            "def test_outputs(self):\n        # standard single-output\n        node = BaseCompositor(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME])\n        assert node.outputs is None\n\n        # even if the sources have multiple outputs, the default here is outputs\n        node = BaseCompositor(sources=[MULTI_0_XY, MULTI_1_XY])\n        assert node.outputs is None",
            "def test_auto_outputs(self):\n        # autodetect single-output\n        node = BaseCompositor(sources=[ARRAY_LAT, ARRAY_LON, ARRAY_TIME], auto_outputs=True)\n        assert node.outputs is None\n\n        # autodetect multi-output\n        node = BaseCompositor(sources=[MULTI_0_XY, MULTI_1_XY], auto_outputs=True)\n        assert node.outputs == [\"x\", \"y\"]\n\n        node = BaseCompositor(sources=[MULTI_0_XY, MULTI_3_Z], auto_outputs=True)\n        assert node.outputs == [\"x\", \"y\", \"z\"]\n\n        node = BaseCompositor(sources=[MULTI_3_Z, MULTI_0_XY], auto_outputs=True)\n        assert node.outputs == [\"z\", \"x\", \"y\"]\n\n        node = BaseCompositor(sources=[MULTI_0_XY, MULTI_4_YX], auto_outputs=True)\n        assert node.outputs == [\"x\", \"y\"]\n\n        # mixed\n        with pytest.raises(ValueError, match=\"Cannot composite standard sources with multi-output sources.\"):\n            node = BaseCompositor(sources=[MULTI_2_X, ARRAY_LAT], auto_outputs=True)\n\n        # no sources\n        node = BaseCompositor(sources=[], auto_outputs=True)\n        assert node.outputs is None",
            "def test_forced_invalid_sources(self):",
            "class MyCompositor(BaseCompositor):\n            sources = [MULTI_2_X, ARRAY_LAT]\n            auto_outputs = True\n\n        node = MyCompositor()\n        with pytest.raises(RuntimeError, match=\"Compositor sources were not validated correctly\"):\n            node.outputs"
        ]
    },
    {
        "file": "/home/cfoye/podpac/podpac/core/compositor/test/test_tiled_compositor.py",
        "comments": [],
        "docstrings": [],
        "code_snippets": [
            "class TestTileCompositor(object):",
            "def test_composition(self):\n        a = ArrayRaw(source=np.arange(5) + 100, coordinates=podpac.Coordinates([[0, 1, 2, 3, 4]], dims=[\"lat\"]))\n        b = ArrayRaw(source=np.arange(5) + 200, coordinates=podpac.Coordinates([[5, 6, 7, 8, 9]], dims=[\"lat\"]))\n        c = ArrayRaw(source=np.arange(5) + 300, coordinates=podpac.Coordinates([[10, 11, 12, 13, 14]], dims=[\"lat\"]))\n\n        node = TileCompositorRaw(sources=[a, b, c])\n\n        output = node.eval(podpac.Coordinates([[3.5, 4.5, 5.5]], dims=[\"lat\"]))\n        np.testing.assert_array_equal(output[\"lat\"], [3, 4, 5, 6])\n        np.testing.assert_array_equal(output, [103, 104, 200, 201])",
            "def test_interpolation(self):\n        a = ArrayRaw(source=np.arange(5) + 100, coordinates=podpac.Coordinates([[0, 1, 2, 3, 4]], dims=[\"lat\"]))\n        b = ArrayRaw(source=np.arange(5) + 200, coordinates=podpac.Coordinates([[5, 6, 7, 8, 9]], dims=[\"lat\"]))\n        c = ArrayRaw(source=np.arange(5) + 300, coordinates=podpac.Coordinates([[10, 11, 12, 13, 14]], dims=[\"lat\"]))\n\n        node = TileCompositor(sources=[a, b, c], interpolation=\"bilinear\")\n\n        output = node.eval(podpac.Coordinates([[3.5, 4.5, 5.5]], dims=[\"lat\"]))\n        np.testing.assert_array_equal(output[\"lat\"], [3.5, 4.5, 5.5])\n        np.testing.assert_array_equal(output, [103.5, 152.0, 200.5])",
            "def test_composition_stacked_multiindex_names(self):\n        a = ArrayRaw(\n            source=np.arange(5) + 100,\n            coordinates=podpac.Coordinates([[[0, 1, 2, 3, 4], [0, 1, 2, 3, 4]]], dims=[\"lat_lon\"]),\n        )\n        b = ArrayRaw(\n            source=np.arange(5) + 200,\n            coordinates=podpac.Coordinates([[[5, 6, 7, 8, 9], [5, 6, 7, 8, 9]]], dims=[\"lat_lon\"]),\n        )\n\n        node = TileCompositorRaw(sources=[a, b])\n\n        output = node.eval(podpac.Coordinates([[[3, 4, 5, 6], [3, 4, 5, 6]]], dims=[\"lat_lon\"]))\n\n        # this is checking that the 'lat' and 'lon' multiindex names are still there\n        np.testing.assert_array_equal(output[\"lat\"], [3, 4, 5, 6])\n        np.testing.assert_array_equal(output[\"lon\"], [3, 4, 5, 6])\n        np.testing.assert_array_equal(output, [103, 104, 200, 201])",
            "def test_get_source_data(self):\n        a = ArrayRaw(source=np.arange(5) + 100, coordinates=podpac.Coordinates([[0, 1, 2, 3, 4]], dims=[\"lat\"]))\n        b = ArrayRaw(source=np.arange(5) + 200, coordinates=podpac.Coordinates([[5, 6, 7, 8, 9]], dims=[\"lat\"]))\n        c = ArrayRaw(source=np.arange(5) + 300, coordinates=podpac.Coordinates([[10, 11, 12, 13, 14]], dims=[\"lat\"]))\n\n        node = TileCompositorRaw(sources=[a, b, c])\n\n        data = node.get_source_data()\n        np.testing.assert_array_equal(data[\"lat\"], np.arange(15))\n        np.testing.assert_array_equal(data, np.hstack([source.source for source in node.sources]))\n\n        # with bounds\n        data = node.get_source_data({\"lat\": (2.5, 6.5)})\n        np.testing.assert_array_equal(data[\"lat\"], [3, 4, 5, 6])\n        np.testing.assert_array_equal(data, [103, 104, 200, 201])\n\n        # error\n        with podpac.settings:\n            podpac.settings.set_unsafe_eval(True)\n            d = podpac.algorithm.Arithmetic(eqn=\"a+2\", a=a)\n        node = TileCompositorRaw(sources=[a, b, c, d])\n        with pytest.raises(ValueError, match=\"Cannot get composited source data\"):\n            node.get_source_data()"
        ]
    }
]